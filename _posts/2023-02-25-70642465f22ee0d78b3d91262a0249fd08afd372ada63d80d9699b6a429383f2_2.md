---
layout: post
title: "70642465f22ee0d78b3d91262a0249fd08afd372ada63d80d9699b6a429383f2[2]"
summary: "70642465f22ee0d78b3d91262a0249fd08afd372ada63d80d9699b6a429383f2[2]"
author: eveheeero
date: '2023-02-25 15:24:07 +0900'
category: ['malware','learning', 'reversing', 'notdoneyet']
tags: malware
thumbnail: /assets/img/posts/2023-02-25-1.png
keywords: malware, reversing
usemathjax: false
permalink: /blog/70642465f22ee0d78b3d91262a0249fd08afd372ada63d80d9699b6a429383f2_2/
---


### [이전 게시글](/blog/70642465f22ee0d78b3d91262a0249fd08afd372ada63d80d9699b6a429383f2/)

> `0x40324C` 이후의 루틴을 분석하였습니다.

![0x40324C 이후의 디스어셈블 코드](/assets/img/posts/2023-02-25-0.png "0x40324C 이후의 디스어셈블 코드입니다.")

해당 주소 이후의 코드는 의미없는 jmp와 jc가 많아, trace기능을 켜고 라인별로 따라갔습니다.

해당 함수 내부에서 함수를 호출하는 부분이 많지 않아 모든 call문 내부에 들어갈 수 있었으며, 호출하는 함수들도 난독화를 위해 생성한 call문이었습니다.

----

해당 루틴 이후로는 다음과 같은 코드가 실행됩니다. (코드가 순서대로 실행되지 않아, 직접 따라가지 않으면 파악할 수 없습니다.)

![Trace 코드](/assets/img/posts/2023-02-25-1.png "Trace로 기록된 실행 로그입니다.")

- `0x40327C` - 스택의 맨 위에서 0x30 값을 가져옵니다. 난독화를 위해 `pop`대신 `mov`, `add`를 사용했습니다.
- `0x403295` - 0으로 맞추어진 `eax`에 `fs:[30]`의 값을 맞춰줍니다. (안티디버깅을 위해 사용하는 PEB블럭)
- `0x4032DC` - `PEB + 0x2`(`BeingDebugged`)의 값을 `ecx`에 넣어줍니다. (진행을 위해 해제해줍니다.)
- `0x403209` - `PEB + 0x68`(`NtGlobalFlag`)의 값을 `eax`에 넣어줍니다. (디버깅중이면 0x70, 아니면 0으로 값이 나옵니다)
- `[0x40124E : 0x401259]` - 반복문을 돌면서 해당 코드 아래의 복호화를 진행합니다.
- `[0x4012C1 : 0x4012C5]` - 반복문을 돌면서 해당 코드 아래의 복호화를 진행합니다.
- `[0x40124E : 0x401259]` - 반복문을 돌면서 해당 코드 아래의 복호화를 진행합니다.

> 중간중간 난독화를 위해 `je A`; `jne A`의 패턴이 자주 보였습니다. 해당 프로텍터의 특징인 것 같습니다.
>
> 중간중간 주소를 `push` 후 `ret`하는 방법을 이용해 `jmp`를 사용하는 루틴이 보입니다.

모든 루틴을 마치고 나면 `0x402BC4`영역에 들어서게 됩니다.

----

이후 비슷한 난독화 코드 루틴을 지나게 됩니다.

- `[0x40124E : 0x401259]` - 반복문을 돌면서 특정 행동을 수행합니다.
- `0x402C04` - `jmp`문의 빈도가 줄어든 것을 보아, 본격적인 로직이 시작될 것 같습니다.
  ![0x402C04](/assets/img/posts/2023-02-25-2.png "0x402C04")
  `push ebp`는 정상적인 함수 도입부라 할 수 없지만, 여태까지는 `call` 이후 `jmp`명령어가 오는 등의 동작이 수행되었었습니다.
- `0x402C30` - `0x402B15`함수 내부로 들어갑니다. 해당 함수 내부에는 정상적인 함수 도입부가 확인됩니다. (난독화는 그대로 남아있습니다.)
- `[0x40124E : 0x401259]` - 반복문을 돌면서 특정 행동을 수행합니다.
- `[0x402B5D : ]` - 정상적인 함수문으로 보입니다. 반복문이 보이는 것 같습니다.
- `0x402B6B` - `0x402A1A` 함수 내부로 들어갑니다. 해당함수는 정상적인 도입부를 가지고 있습니다.
- `0x402A62` - `0x4011F5` 내부로 들어갑니다. 제대로 된 함수는 아니며, 이후 공간에서 바로 SetErrorModeStub의 주소를 다루는것을 보아 난독화 해제가 거의 끝난것같습니다.
  추가적으로, 실수로 건너서 진행을 눌러 오류가 떴는데, `0x402A62` 바로 아래의 구문에서 오류가 나타난것을 보아 곧 메인함수가 실행될 것 같습니다.
- `[0x40124E : 0x401259]` - 반복문을 돌면서 특정 행동을 수행합니다.
- `[0x402A67 : ]` - 반복문에서 빠져나간 이후, ntdll의 여러 함수 주소를 가져옵니다. 사용할 준비를 하는 것 같습니다.
  ![loop 이후의코드](/assets/img/posts/2023-02-25-3.png "ntdll의 여러 주소를 가져오는내용으로 추정됩니다..")
- `[0x402A85 : 0x402AA9]` - 반복문을 통해 커널 내부 문자열처리를 하는것으로 보입니다.
- `[0x40124E : 0x401259]` - 반복문을 돌면서 특정 행동을 수행합니다.
- `0x402B80` - (위에서 두번째 라인의 부분으로 `ret`을 통해 돌아왔습니다.)
- `[0x402B62 : 0x402B7C]` - 커널 내부 문자열 처리를 반복합니다.
- `[0x40124E : 0x401259]` - 반복문을 통해 특정 행동을 수행합니다.
- `0x402C35` - 두 번의 연속 `ret` 이후 `test`를 수행합니다. 디버거가 붙어있는지 확인하는 로직인 것 같습니다.
  ![두번의 ret 이후의 코드](/assets/img/posts/2023-02-25-4.png "test 이후 실패했으면 먼 곳으로 보내버립니다.")
  해당 코드의 아래편에는 `jmp`문이 없는 데이터공간이 있었습니다.
- `0x402CCA` - `0x402D10` 내부로 진입합니다. 해당 구역으로 진입한 이후에는 여러 문자열을 볼 수 있습니다.
- `0x4029AC` - 계속 진행하다보면 `kernel32`을 인자로 RtlInitUnicodeString 함수를 호출하는 구문까지 나오게 됩니다.
  ![kernel32문자열을 가공하는 모습](/assets/img/posts/2023-02-25-5.png "RtlInitUnicodeString함수 호출")
- `0x4029C2` - `LdrLoadDll`함수를 호출한다.
- `[0x4029C2 : ]` - 해당 코드 이후 추가 처리를 통해 여러 라이브러리를 로딩합니다. `kernel32` 이후 똑같은 `0x4029AC`에서 `user32`이후 `LoadDll`사용
  ![user32문자열을 가공하는 모습](/assets/img/posts/2023-02-25-6.png "RtlInitUnicodeString함수 호출")

> 여러 반복문은 커널 내부에 후킹이 있었는지 판단하기 위한 로직이 아닐까 추측합니다.

해당 부분에서 동일한 `0x4029AC`가 두번이상 호출되어, 호출스택을 확인해보니 `[0x402D1C : 0x402D36]`부분을 루프돌면서 여러 라이브러리를 로딩하고 있었습니다.
![루프문](/assets/img/posts/2023-02-25-7.png "반복하면서 문자열을 복호화, 가공 후 Dll을 로드하던 부분, 실패하면 종료하는듯하다.")

- 이후 추가 로직 처리 후 `0x402A67`로 나오게 됩니다. (`0x402A62`에서 설명한 주소입니다.)
  ![0x402A67](/assets/img/posts/2023-02-25-8.png){: width="100%" height="100%"}
- `[0x402A85 : 0x402AA9]` - 반복문을 함수 이름을 불러온다.
  ![반복하면서 함수 이름을 가져오는 부분](/assets/img/posts/2023-02-25-9.png "반복하면서 함수 이름을 가져오는 부분입니다.")

이후 계속 진행해보니, 함수 이름을 가져오는 부분을 반복하고 있었습니다. 함수 이름을 통해 함수주소를 가져오는 로직인 것 같습니다.

호출스택을 통해 확인해보니, 반복문을 통해 해당 함수를 호출하고 있었습니다.
![반복하면서 함수 이름을 가져오는 부분](/assets/img/posts/2023-02-25-10.png "반복하면서 함수 이름을 가져오는 부분입니다.")

> > 해당 부분에서 키보드 오입력때문에 작업내용이 날라갔습니다. 이후 추가로 다시작성해야 할 것 같습니다.
>
> 덤프 플러그인의 사용법을 잘 모르겠어서 파이썬 자동화 툴이나 스크립트를 만든 후 작업해야할것같습니다
>
> 특정 어려운 기법이 사용된것이 아니여서 계속 지켜보면서 감으로 스킵하는 수 밖에 없어보입니다.
>
> 해당 이후의 부분은 추후 작성할 예정입니다.
