---
layout: post
title: "osu!gamingCTF 2025 문제풀이"
summary: "osu!gamingCTF 2025 문제풀이"
author: eveheeero
date: '2025-10-28 00:18:00 +0900'
category: ['ctf', 'reversing', 'learning']
tags: ctf
thumbnail: /assets/img/posts/2025-10-28-1.png
keywords: ctf
usemathjax: false
permalink: /blog/osu-gaming-ctf-2025/
---

## 배경

`RubiyaLab CTF`팀으로 `osu!gamingCTF`에 참여하게 되었습니다.

dddfasdsasdasdd

`기간 : 2025-10-25 11:00 ~ 2025-10-27 11:00 (KST)`

## 문제 목록

푼 순서대로

- `tosu-1` - `rev 점수 - 265점, 푼 팀 - 17/648팀 First Blood`
- `tosu-2` - `rev 점수 - 362점, 푼 팀 - 8/648팀 First Blood`
- `modulation-master` - `ppc 점수 - 202점, 푼 팀 - 30/648팀`

### Unsolved

- .

## tosu-1

### 문제 상황

![_](/assets/img/posts/2025-10-28-4.png){: style="max-width: 100%; height: auto;"}

`mfc` 및 `direct x`로 이루어진 리듬게임입니다.

올 퍼펙트를 하면 성공입니다.

### 분석 과정

![_](/assets/img/posts/2025-10-28-5.png){: style="max-width: 100%; height: auto;"}

메인 내부, `direct x` 창 생성 이후 goto를 이용한 루프 로직이 존재합니다.

![_](/assets/img/posts/2025-10-28-6.png){: style="max-width: 100%; height: auto;"}

화면 입력 관련 처리 함수(`0x140043250`)가 보입니다. 점수 관련 처리 로직이 있진 않아 무시해도 됩니다.

![_](/assets/img/posts/2025-10-28-7.png){: style="max-width: 100%; height: auto;"}

내려가다보면 점수 출력 및 플래그 출력 함수가 보입니다. SCORE 변수를 따라가면 같은 함수 내부에서 점수를 처리하는 로직이 보입니다.

![_](/assets/img/posts/2025-10-28-9.png){: style="max-width: 100%; height: auto;"}

![_](/assets/img/posts/2025-10-28-8.png){: style="max-width: 100%; height: auto;"}

점수 계산 로직 위에는 타이밍을 이용해 점수 타입을 계산하는 루프가, 또 그 위에는 어떤 과녁을 맞췄는지 계산하는 로직이 있는 것으로 보였습니다.

루프 시작부분에 커서 위치 및 과녁을 계산하는 로직, 클릭 검증 로직, 과녁을 검증하는 로직, 타이밍 기반으로 점수를 계산하는 로직을 패치해서 실행하니 점수가 많이 맞았습니다. 하지만 점수가 부족했습니다.

![_](/assets/img/posts/2025-10-28-10.png){: style="max-width: 100%; height: auto;"}

과녁은 시스템 시계 기반으로 동작하기 때문에, 1틱당 1과녁을 클릭해도 풀콤보가 되지 않는 것으로 보입니다.

![_](/assets/img/posts/2025-10-28-11.png){: style="max-width: 100%; height: auto;"}

클릭 관련 이벤트 처리 시작부분을 살펴보니 `0.2`를 가지고 데이터를 조작하는것이 보였습니다. 확인해보니 놓친 과녁에 대해 처리하는 로직이었습니다.

분석해보니 `0x140004e60`함수가 과녁 터치에 대해 플래그를 계산하는 로직이었습니다. (50, 100, 300점 처리 로직 이후에도 있었음) 해당 함수에 항상 3을 들어가게 함으로써 플래그를 얻을 수 있었습니다.

![_](/assets/img/posts/2025-10-28-12.png){: style="max-width: 100%; height: auto;"}

![_](/assets/img/posts/2025-10-28-13.png){: style="max-width: 100%; height: auto;"}

## tosu-2

### 문제 상황

비슷한 프로그램이지만, 풀 콤보를 진행하는 것으로 플래그를 얻을 수 없습니다. 특정 순서에 맞는 노트를 히트해야하 성공합니다.

1080개의 느트가 히트됐으면 1, 아니면 0으로 메모장에 기록되어 파일이 생성됩니다.

### 분석 과정

.

## modulation-master

### 문제 상황

아래와 같은 사이트가 주어집니다.

![_](/assets/img/posts/2025-10-28-0.png){: style="max-width: 100%; height: auto;"}

start버튼을 누를 경우 아래와 같은 이미지가 나오며, 2초 내에 해당 이미지를 인식해 ascii코드로 입력해야 합니다.

![_](/assets/img/posts/2025-10-28-1.png){: style="max-width: 100%; height: auto;"}

![_](/assets/img/posts/2025-10-28-2.png){: style="max-width: 100%; height: auto;"}

### 분석 과정

크로미움 및 크로미움 드라이버를 이용해 자동화를 진행했습니다.

첫 시도는 전체 코드를 llm을 이용해 짰다가, 인식률이 좋지 않아 절대좌표를 통해 영역을 나눠 진행하였습니다.

![_](/assets/img/posts/2025-10-28-3.png){: style="max-width: 100%; height: auto;"}

기준점이 되는 좌표는 다음과 같았습니다.

```txt
y - 27, 331px
x - 60, 252, 446, 640, 834, 1028, 1221, 1415, 1607px
```

위 좌표를 이용해 8개 영역으로 나눈 뒤, 첫번째 영역을 무조건 0으로 치환하여 (아스키 범위는 0x7f를 벗어나지 않음), 첫번째 영역과 다른 영역을 1로 인식하였습니다.

위처럼 시도하였을 때 경계 관련하여 인식 문제가 생겨, 90%정도의 영역만을 인식해 검사하였습니다.

```python
import os
import re
import time
import base64
import numpy as np
from io import BytesIO
from typing import List, Tuple, Optional

import cv2
from PIL import Image

from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.chrome.service import Service

URL = "https://modulation-master-9e36f9625dce.instancer.sekai.team/"
TOTAL_ROUNDS = 110
SAVE_DIR = "images"

# ----- 고정 경계 (원본 좌표계) -----
Y_TOP, Y_BOTTOM = 27, 331
# Y_TOP, Y_BOTTOM = 270, 300
X_BOUNDS = [60, 252, 446, 640, 834, 1028, 1221, 1415, 1607]  # 9개 → 8구역
BASE_W = X_BOUNDS[-1]  # 1607
BASE_H = Y_BOTTOM  # 331

# 템플릿 중앙 크기 비율(필요시 조정)
CENTER_FRAC_X = 0.90
CENTER_FRAC_Y = 0.90
SIM_THRESHOLD = 0.90  # 90% 이상 일치면 같은 신호(=0)

# ----- 유틸 -----
PRINT_MIN, PRINT_MAX = 32, 126
SETTLE_MS=35



def wait_for_img_loaded_and_settled(driver, timeout=15, settle_ms: int = SETTLE_MS):
    """img#textImage가 로드되고(complete/decode) 아주 짧은 텀을 준다."""
    w = WebDriverWait(driver, timeout)
    img = w.until(EC.presence_of_element_located((By.CSS_SELECTOR, "img#textImage")))
    # complete & naturalWidth>0
    w.until(
        lambda d: d.execute_script(
            "const i=document.querySelector('img#textImage');return i && i.complete && i.naturalWidth>0;"
        )
    )

    # decode() + 2 frames + short timeout
    script = f"""
    const done = arguments[0];
    (async () => {{
      const i = document.querySelector('img#textImage');
      if (!i) return done(false);
      try {{
        if ('decode' in i) {{
          try {{ await i.decode(); }} catch (e) {{}}
        }} else {{
          if (!i.complete) {{
            await new Promise(res => {{ i.onload = () => res(); i.onerror = () => res(); }});
          }}
        }}
        await new Promise(r => requestAnimationFrame(() => r()));
        await new Promise(r => requestAnimationFrame(() => r()));
        setTimeout(() => done(true), {settle_ms});
      }} catch (e) {{
        setTimeout(() => done(true), {settle_ms});
      }}
    }})();
    """
    driver.set_script_timeout(timeout)
    driver.execute_async_script(script)
    return img


def get_png_bytes_via_canvas(driver) -> Optional[bytes]:
    """현재 img#textImage를 캔버스로 그려 PNG 바이트 추출(재로드 없음)."""
    js = """
    const i = document.querySelector('img#textImage');
    if (!i || !i.complete || i.naturalWidth===0) return null;
    try {
      const c = document.createElement('canvas');
      c.width = i.naturalWidth; c.height = i.naturalHeight;
      const ctx = c.getContext('2d'); ctx.imageSmoothingEnabled=false;
      ctx.drawImage(i, 0, 0);
      return c.toDataURL('image/png');
    } catch(e){ return null; }
    """
    data_url = driver.execute_script(js)
    if not isinstance(data_url, str) or "," not in data_url:
        return None
    try:
        _, b64 = data_url.split(",", 1)
        b = base64.b64decode(b64)
        return b if len(b) > 0 else None
    except Exception:
        return None


def save_img_from_page(driver, img_el, path: str) -> Image.Image:
    """안정화 텀 이후 캔버스→PNG 저장. 실패 시 요소 스크린샷 폴백."""
    os.makedirs(SAVE_DIR, exist_ok=True)
    png_bytes = get_png_bytes_via_canvas(driver)
    if png_bytes is not None and len(png_bytes) > 0:
        with open(path, "wb") as f:
            f.write(png_bytes)
        return Image.open(BytesIO(png_bytes)).convert("RGB")
    # 폴백
    img_el.screenshot(path)
    return Image.open(path).convert("RGB")


# ===================== 비트/ASCII 유틸 =====================


def ascii_from_bits8(bits8: str) -> Optional[str]:
    if len(bits8) != 8 or re.search(r"[^01]", bits8):
        return None
    val = int(bits8, 2)
    return chr(val) if PRINT_MIN <= val <= PRINT_MAX else None


def choose_ascii(bits8: str) -> str:
    c = ascii_from_bits8(bits8)
    if c is not None:
        return c
    c = ascii_from_bits8(bits8[::-1])
    return c if c is not None else "?"


# ===================== 고정 좌표 + 템플릿 포함 판정 =====================


def binarize_crop(
    img_gray: np.ndarray, x0: int, x1: int, y0: int, y1: int
) -> np.ndarray:
    """크롭→이진화→팽창→bool mask"""
    x0 = max(0, min(x0, img_gray.shape[1] - 1))
    x1 = max(0, min(x1, img_gray.shape[1]))
    y0 = max(0, min(y0, img_gray.shape[0] - 1))
    y1 = max(0, min(y1, img_gray.shape[0]))
    if x1 <= x0 or y1 <= y0:
        return np.zeros((1, 1), dtype=bool)

    roi = img_gray[y0:y1, x0:x1]
    _, bw = cv2.threshold(roi, 230, 255, cv2.THRESH_BINARY_INV)
    if (np.count_nonzero(bw) / bw.size) < 0.002:
        _, bw = cv2.threshold(roi, 0, 255, cv2.THRESH_BINARY_INV + cv2.THRESH_OTSU)
    bw = cv2.dilate(bw, np.ones((3, 3), np.uint8), iterations=1)
    return bw > 0


def best_subset_match_fraction(
    region_mask: np.ndarray, template_mask: np.ndarray
) -> float:
    """max overlap fraction of template inside region."""
    reg = region_mask.astype(np.uint8)
    tpl = template_mask.astype(np.uint8)

    rh, rw = reg.shape
    th, tw = tpl.shape
    if th > rh or tw > rw:
        scale = min(rh / max(th, 1), rw / max(tw, 1))
        scale = max(scale, 0.1)
        new_w = max(1, int(round(tw * scale)))
        new_h = max(1, int(round(th * scale)))
        tpl = cv2.resize(tpl, (new_w, new_h), interpolation=cv2.INTER_NEAREST)
        th, tw = tpl.shape

    tpl_ones = int(np.count_nonzero(tpl))
    if tpl_ones == 0:
        return 1.0 if int(np.count_nonzero(reg)) == 0 else 0.0

    conv = cv2.filter2D(reg.astype(np.float32), -1, tpl.astype(np.float32))
    best = float(np.max(conv)) if conv.size > 0 else 0.0
    return best / float(tpl_ones)


def bits_from_fixed_regions_with_template(
    pil_img: Image.Image,
    sim_threshold: float = SIM_THRESHOLD,
    center_frac_x: float = CENTER_FRAC_X,
    center_frac_y: float = CENTER_FRAC_Y,
) -> Tuple[str, List[float], Tuple[int, int]]:
    """
    0번 구역 중앙 조각 템플릿으로 각 구역 포함율(최대 겹침) 비교 → 비트(0/1)
    - 첫 비트는 무조건 0
    """
    img = np.array(pil_img)
    H, W = img.shape[:2]
    sx = W / float(BASE_W)
    sy = H / float(BASE_H)

    gray = cv2.cvtColor(img, cv2.COLOR_RGB2GRAY)

    masks: List[np.ndarray] = []
    for i in range(8):
        x0 = int(round(X_BOUNDS[i] * sx))
        x1 = int(round(X_BOUNDS[i + 1] * sx))
        y0 = int(round(Y_TOP * sy))
        y1 = int(round(Y_BOTTOM * sy))
        masks.append(binarize_crop(gray, x0, x1, y0, y1))

    # 0번 구역 → 중앙 템플릿
    ref = masks[0]
    rh, rw = ref.shape
    tpl_w = max(1, int(round(rw * center_frac_x)))
    tpl_h = max(1, int(round(rh * center_frac_y)))
    xs = max(0, (rw - tpl_w) // 2)
    ys = max(0, (rh - tpl_h) // 2)
    template = ref[ys : ys + tpl_h, xs : xs + tpl_w]

    # 템플릿이 너무 비면 보정
    if np.count_nonzero(template) < 10:
        tpl_w2 = max(1, int(round(rw * 0.8)))
        tpl_h2 = max(1, int(round(rh * 0.8)))
        xs2 = max(0, (rw - tpl_w2) // 2)
        ys2 = max(0, (rh - tpl_h2) // 2)
        template = ref[ys2 : ys2 + tpl_h2, xs2 : xs2 + tpl_w2]
        if np.count_nonzero(template) < 10:
            template = ref

    sims: List[float] = []
    bits: List[str] = []
    for i, m in enumerate(masks):
        if i == 0:
            sims.append(1.0)
            bits.append("0")  # 첫 비트 강제 0
            continue
        s = best_subset_match_fraction(m, template)
        sims.append(s)
        bits.append("0" if s >= sim_threshold else "1")

    return "".join(bits), sims, template.shape


# ===================== 한 라운드 처리 =====================


def solve_round(driver, idx: int) -> Tuple[str, List[float], str, Tuple[int, int]]:
    img_el = wait_for_img_loaded_and_settled(driver, timeout=20, settle_ms=SETTLE_MS)
    old_src_before_submit = img_el.get_attribute("src") or ""

    # 안정화 텀 후 픽셀 추출 → 저장
    path = os.path.join(SAVE_DIR, f"{idx}.png")
    pil_img = save_img_from_page(driver, img_el, path)

    bits8, sims, tpl_shape = bits_from_fixed_regions_with_template(pil_img)
    answer = choose_ascii(bits8)

    # 입력/제출
    ans_box = WebDriverWait(driver, 10).until(
        EC.presence_of_element_located((By.CSS_SELECTOR, "input#answer"))
    )
    ans_box.clear()
    ans_box.send_keys(answer)

    submit_btn = WebDriverWait(driver, 10).until(
        EC.element_to_be_clickable((By.CSS_SELECTOR, "button#submit"))
    )
    submit_btn.click()

    # 다음 문제 로딩 대기(src 변경)
    WebDriverWait(driver, 15).until(
        lambda d: d.find_element(By.CSS_SELECTOR, "img#textImage").get_attribute("src")
        != old_src_before_submit
    )

    return bits8, sims, answer, tpl_shape


# ===================== 메인 =====================


def main():
    os.makedirs(SAVE_DIR, exist_ok=True)

    chrome_opts = Options()
    # 헤드리스 금지(요청)
    chrome_opts.add_argument("--disable-gpu")
    chrome_opts.add_argument("--no-sandbox")
    chrome_opts.add_argument("--window-size=1400,1000")
    chrome_opts.add_argument("--lang=ko-KR,ko")

    driver = webdriver.Chrome(
        service=Service(ChromeDriverManager().install()), options=chrome_opts
    )
    wait = WebDriverWait(driver, 20)

    driver.get(URL)
    start_btn = wait.until(
        EC.element_to_be_clickable((By.CSS_SELECTOR, "button#start"))
    )
    start_btn.click()

    # 첫 문제 로딩 + 안정화
    wait_for_img_loaded_and_settled(driver, timeout=20, settle_ms=SETTLE_MS)

    for i in range(1, TOTAL_ROUNDS + 1):
        try:
            bits8, sims, answer, tpl_shape = solve_round(driver, i)
            print("=" * 70)
            print(
                f"[Round {i}] saved=images/{i}.png, template={tpl_shape[0]}x{tpl_shape[1]}, settle_ms={SETTLE_MS}"
            )
            print(
                f"- 포함 유사도(max overlap, ref piece vs region): "
                + ", ".join(f"{s:.3f}" for s in sims)
            )
            print(f"- 최종 8비트         : {bits8} (bit0=0)")
            print(f"- 제출한 문자        : {answer}")
            time.sleep(0.05)  # 서버/DOM 다음 상태 준비 미세 텀
        except Exception as e:
            print("=" * 70)
            print(f"[Round {i}] 오류: {e}")
            time.sleep(0.3)

    driver.quit()
    print("\n완료.")


if __name__ == "__main__":
    main()
```

왜 이리 코드가 길어졌는지는 모르겠습니다.

## 작성자의 글

- .

## 참조

- .
